
"""metaprompt\

Write a python class that picks up changes in a latex file as described below.
The latex file consists of designated environment:

\begin{user}
some user text

% parameters:  <some user parameters>
\end{user}

\begin{reasoning}
agent text
\end{reasoning}

Given two versions of the latex file, one of which preceds the other, a diff method should
return a list of dictionaries consisting of any new environments of the types 'user' and 'reasoning' in the new version. 
That is, a list whose entries are:

{
 "type": <user/reasoning>, 
 "text": <content>, 
 "params": <parameters>
 }

 where <parameters> are parsed from the comments within the user environment.

 The class should include methods:

 __init__(current_version.tex)
 commit(new_version.tex): commits a new version (alongside the previous one) of the latex document 
 diff(): returns a list of newly added environments from the new version.
 envs(): returns the list of environments from the current version.
 
 push(new_envs): updates and pastes new environments into the new version by finding their proper
 locations within the new version. The list new_envs contains existing environments followed by new ones
 which should appear right after them in the new version. For example, 
 new_env = [{"before": {"user": this is an existing env}, 
 "after": {"reasoning": this is a new environment that should appear right after in the new version}},...]   
 
 save(file): saves the new version to file.tex and update current_version to the new one.

 /-----/
 Can you add a method for streaming in an environment. That is, similar to push with the only difference
 that the values of the "after" key are pushed and saved to the new file sequentially. For example,

 tracker.stream(new_env=["before": {"user": "this is an existing env"}, "after": {"reasoning": iterator}], new_version.tex)

 incorporates the stream of chars generated by the iterator in their proper place within the new_version.tex. 
"""

import re
import os
import fcntl
import time
from typing import List, Dict, Any, Union, Optional, Iterator, Iterable
from datetime import datetime
from pathlib import Path


class LaTeXEnvTracker:
    """
    A class to track changes in LaTeX environments, specifically 'user' and 'reasoning' environments.
    The class tracks versions of a LaTeX file and provides methods to identify new environments,
    manage environments, and update the file with new environments.
    """

    def __init__(self, current_version_file: str):
        """
        Initialize the tracker with the current version of the LaTeX file.
        
        Args:
            current_version_file (str): Path to the current LaTeX file
        """
        self.current_version_file = current_version_file
        self.new_version_file = None
        self.recent_reasoning_time = 0.0
        
        # Read the current version
        with open(current_version_file, 'r', encoding='utf-8') as f:
            self.current_content = f.read()
        
        # Initialize new_content as current_content initially
        self.new_content = self.current_content
        
        # Parse environments in the current version
        self.current_envs = self._parse_environments(self.current_content)
    
    def _parse_parameters(self, text: str) -> Dict[str, str]:
        """
        Parse parameters from the comment line within a user environment.
        
        Args:
            text (str): The content of the user environment
            
        Returns:
            Dict[str, str]: Dictionary of parameter key-value pairs
        """
        params = {}
        param_line_match = re.search(r'%\s*parameters:\s*(.*?)(?:\n|$)', text, re.DOTALL | re.IGNORECASE)
        
        if param_line_match:
            param_text = param_line_match.group(1).strip()
            # Parse key-value pairs
            param_pairs = re.findall(r'(\w+)\s*=\s*([^,]+)(?:,|$)', param_text)
            for key, value in param_pairs:
                params[key.strip()] = value.strip()
        
        return params
    
    def _parse_environments(self, content: str) -> List[Dict[str, Any]]:
        """
        Parse all user and reasoning environments from the LaTeX content.
        
        Args:
            content (str): LaTeX content to parse
            
        Returns:
            List[Dict[str, Any]]: List of dictionaries containing environment information
        """
        envs = []
        
        # Find all user environments
        user_pattern = r'\\begin{user}(.*?)\\end{user}'
        user_matches = re.finditer(user_pattern, content, re.DOTALL)
        
        for match in user_matches:
            env_text = match.group(1).strip()
            params = self._parse_parameters(env_text)
            
            # Clean the text by removing the parameters line
            clean_text = re.sub(r'%\s*parameters:.*?(?:\n|$)', '', env_text, flags=re.DOTALL).strip()
            
            envs.append({
                "type": "user",
                "text": clean_text,
                "params": params,
                "start": match.start(),
                "end": match.end()
            })
        
        # Find all reasoning environments
        reasoning_pattern = r'\\begin{reasoning}(.*?)\\end{reasoning}'
        reasoning_matches = re.finditer(reasoning_pattern, content, re.DOTALL)
        
        for match in reasoning_matches:
            env_text = match.group(1).strip()
            
            envs.append({
                "type": "reasoning",
                "text": env_text,
                "params": {},
                "start": match.start(),
                "end": match.end()
            })
        
        # Sort environments by their position in the document
        envs.sort(key=lambda x: x["start"])
        
        return envs
    
    def commit(self, new_version_file: str) -> None:
        """
        Commit a new version of the LaTeX file to compare with the current version.
        
        Args:
            new_version_file (str): Path to the new LaTeX file
        """
        self.new_version_file = new_version_file
        
        # Read the new version
        with open(new_version_file, 'r', encoding='utf-8') as f:
            self.new_content = f.read()
        
        # Parse environments in the new version
        self.new_envs = self._parse_environments(self.new_content)
    
    def _env_equals(self, env1: Dict[str, Any], env2: Dict[str, Any]) -> bool:
        """
        Check if two environment dictionaries are equivalent (ignoring position).
        
        Args:
            env1 (Dict[str, Any]): First environment dictionary
            env2 (Dict[str, Any]): Second environment dictionary
            
        Returns:
            bool: True if the environments are equivalent, False otherwise
        """
        return (env1["type"] == env2["type"] and 
                env1["text"] == env2["text"] and 
                env1["params"] == env2["params"])
    
    def _env_in_list(self, env: Dict[str, Any], env_list: List[Dict[str, Any]]) -> bool:
        """
        Check if an environment is in a list of environments.
        
        Args:
            env (Dict[str, Any]): Environment to check
            env_list (List[Dict[str, Any]]): List of environments
            
        Returns:
            bool: True if the environment is in the list, False otherwise
        """
        for existing_env in env_list:
            if self._env_equals(env, existing_env):
                return True
        return False
    
    def diff(self) -> List[Dict[str, Any]]:
        """
        Calculate the difference between the current and new versions,
        returning a list of newly added environments.
        
        Returns:
            List[Dict[str, Any]]: List of new environments
        """
        if self.new_version_file is None:
            raise ValueError("No new version has been committed")
        
        new_envs = []
        
        for env in self.new_envs:
            # Check if this environment exists in the current version
            if not self._env_in_list(env, self.current_envs):
                # Add to the list of new environments (exclude position information)
                new_envs.append({
                    "type": env["type"],
                    "text": env["text"],
                    "params": env["params"]
                })
        
        return new_envs
    
    def marked_env(self, key, value) -> List[Dict[str, Any]]:
        """
        Look for marked envrionments, e.g., status=start (key, value= 'status', 'start'),
        returning a list of such designated environments.
        
        Returns:
            List[Dict[str, Any]]: List of designated environments
        """
        if self.new_version_file is None:
            raise ValueError("No new version has been committed")
        
        new_envs = []
        
        for env in self.new_envs:
           
           if env.get("params", {}).get(key, None) == value:
                new_envs.append({
                    "type": env["type"],
                    "text": env["text"],
                    "params": env["params"]
                })
        
        return new_envs
    
    def envs(self) -> List[Dict[str, Any]]:
        """
        Return the list of environments from the current version.
        
        Returns:
            List[Dict[str, Any]]: List of environments in the current version
        """
        # Return without position information
        return [{"type": env["type"], "text": env["text"], "params": env["params"]} 
                for env in self.current_envs]
    
    def _find_env_by_content(self, env_type: str, text: str, 
                            env_list: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Find an environment in a list by its type and text content.
        
        Args:
            env_type (str): Type of environment ('user' or 'reasoning')
            text (str): Text content to match
            env_list (List[Dict[str, Any]]): List of environments to search
            
        Returns:
            Optional[Dict[str, Any]]: The matching environment or None if not found
        """
        for env in env_list:
            if env["type"] == env_type and env["text"].strip() == text.strip():
                return env
        return None
    
    def update_env(self, env_to_update: Dict, updated_text: str) -> None:

        if self.new_version_file is None:
            raise ValueError("No new version has been committed")
        
        # Create a working copy of the content
        updated_content = self.new_content

        env_type = env_to_update.get("type", "")
        env_text = env_to_update.get("text", "")

        found_env = self._find_env_by_content(
            env_type,
            env_text, 
            self.new_envs)
            
        if found_env:
            # Prepare the text to insert
            insert_text = f"\n\\begin{{{env_type}}}\n{updated_text}\n\\end{{{env_type}}}"
            
            # Find the position right after the 'before' environment
            insert_pos = [found_env["start"], found_env['end']]
            
            # Insert the new environment
            updated_content = (updated_content[:insert_pos[0]] + 
                                insert_text + 
                                updated_content[insert_pos[1]:])
            
            # Update the positions of environments after the insertion point
            offset = len(insert_text) - (insert_pos[1]-insert_pos[0])
            for env in self.new_envs:
                if env["start"] > insert_pos[1]:
                    env["start"] += offset
                    env["end"] += offset

            self.new_content = updated_content

    
    def push(self, new_envs: List[Dict[str, Dict[str, str]]]) -> None:
        """
        Update the new version with additional environments.
        
        Args:
            new_envs (List[Dict[str, Dict[str, str]]]): List of before/after environment pairs
        """
        if self.new_version_file is None:
            raise ValueError("No new version has been committed")
        
        # Create a working copy of the content
        updated_content = self.new_content
        
        # Process each pair of environments
        for pair in new_envs:
            before_env = pair.get("before", {})
            after_env = pair.get("after", {})
            
            if not before_env or not after_env:
                continue
            
            # Extract details from the before environment
            before_type = list(before_env.keys())[0]
            before_text = before_env[before_type]
            
            # Extract details from the after environment
            after_type = list(after_env.keys())[0]
            after_text = after_env[after_type]
            
            # Find the 'before' environment in the new version
            found_env = self._find_env_by_content(before_type, before_text, self.new_envs)
            
            if found_env:
                # Prepare the text to insert
                insert_text = f"\n\\begin{{{after_type}}}\n{after_text}\n\\end{{{after_type}}}"
                
                # Find the position right after the 'before' environment
                insert_pos = found_env["end"]
                
                # Insert the new environment
                updated_content = (updated_content[:insert_pos] + 
                                  insert_text + 
                                  updated_content[insert_pos:])
                
                # Update the positions of environments after the insertion point
                offset = len(insert_text)
                for env in self.new_envs:
                    if env["start"] > insert_pos:
                        env["start"] += offset
                        env["end"] += offset
                
                # Add the new environment to our list
                self.new_envs.append({
                    "type": after_type,
                    "text": after_text,
                    "params": {},
                    "start": insert_pos,
                    "end": insert_pos + offset
                })
                
                # Re-sort environments by position
                self.new_envs.sort(key=lambda x: x["start"])
        
        # Update the new content
        self.new_content = updated_content

    @staticmethod
    def write_with_lock(filepath, content, max_attempts=5, retry_delay=1):
        filepath = Path(filepath)
        lock_path = filepath.with_suffix(filepath.suffix + ".lock")
        
        attempt = 0
        while attempt < max_attempts:
            lock_file = open(lock_path, 'w')
            try:
                try:
                    fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
                    # Lock acquired, write the file
                    with open(filepath, 'w') as f:
                        f.write(content)
                        f.flush()
                        os.fsync(f.fileno())
                    return  # Successfully wrote the file
                except BlockingIOError:
                    # Lock couldn't be acquired
                    attempt += 1
                    if attempt >= max_attempts:
                        raise TimeoutError(f"Could not acquire lock for {filepath} after {max_attempts} attempts")
                    print(f"Lock already held, retrying in {retry_delay} seconds (attempt {attempt}/{max_attempts})")
                    time.sleep(retry_delay)
            finally:
                try:
                    fcntl.flock(lock_file, fcntl.LOCK_UN)
                except:
                    pass  # Ignore errors when releasing a lock we might not have
                lock_file.close()
                if os.path.exists(lock_path):
                    try:
                        os.remove(lock_path)
                    except:
                        pass  # Ignore errors when removing the lock file

    
    def save(self, file_path: str) -> None:
        """
        Save the updated content to a file and update the current version.
        
        Args:
            file_path (str): Path to save the updated LaTeX file
        """
        if self.new_version_file is None:
            raise ValueError("No new version has been committed")
        
        # Write the updated content to the specified file
        #with open(file_path, 'w', encoding='utf-8') as f:
        #    f.write(self.new_content)

        self.write_with_lock(file_path, self.new_content)
        
        # Update the current version information
        self.current_version_file = file_path
        self.current_content = self.new_content
        self.current_envs = self.new_envs
        
        # Reset the new version
        self.new_version_file = None
        self.new_envs = []
        
    def stream(self, new_env: Dict[str, Dict[str, Union[str, Iterator[str]]]], output_file: str) -> None:
        """
        Stream content into a new environment and save it to a file in real-time.
        The file is updated incrementally, showing all existing content plus the
        streaming content as it's generated.
        
        Args:
            new_env (Dict): Dictionary with 'before' and 'after' keys, where 'after' contains an iterator
            output_file (str): Path to save the updated LaTeX file
        """
        if self.new_version_file is None:
            raise ValueError("No new version has been committed")
            
        # Extract details from the before environment
        before_env = new_env.get("before", {})
        after_env = new_env.get("after", {})
        etitle = new_env.get("title", None)
        env_title = '['+etitle+']' if etitle else ''
        
        if not before_env or not after_env:
            raise ValueError("Both 'before' and 'after' environments must be provided")
        
        # Extract type and content from the before environment
        before_type = list(before_env.keys())[0]
        before_text = before_env[before_type]
        
        # Extract type and iterator from the after environment
        after_type = list(after_env.keys())[0]
        content_iterator = after_env[after_type]
        
        if not isinstance(content_iterator, Iterable):
            raise ValueError("The 'after' value must be an iterator")
        
        # Find the 'before' environment in the new version
        found_env = self._find_env_by_content(before_type, before_text, self.new_envs)
        
        if not found_env:
            raise ValueError(f"Could not find the 'before' environment: {before_type} with text '{before_text}'")
        
        # Find the position right after the 'before' environment
        insert_pos = found_env["end"]
        
        # Split the content at the insertion point
        prefix = self.new_content[:insert_pos]
        suffix = self.new_content[insert_pos:]
        
        # First, write the complete file with a placeholder for the streamed content
        # with open(output_file, 'w', encoding='utf-8') as f:
        #     f.write(prefix)
        #     f.write(f"\n\\begin{{{after_type}}}{env_title}\n")
        #     f.write("... streaming content will appear here ...")
        #     f.write(f"\n\\end{{{after_type}}}\n")
        #     f.write(suffix)

        placeholder = (
            prefix +
            f"\n\\begin{{{after_type}}}{env_title}\n" +
            "... streaming content will appear here ..." +
            f"\n\\end{{{after_type}}}\n" +
            suffix
        )

        self.write_with_lock(output_file, placeholder)
        
        # Now stream the content by reading, modifying, and writing back the file
        streamed_content = ""

        start_time = time.time()
        
        for chunk in content_iterator:
            # Accumulate the streamed content
            streamed_content += chunk
            
            # Read the current file content
            with open(output_file, 'r', encoding='utf-8') as f:
                current_file_content = f.read()
            
            # Construct the updated content with the latest streamed content
            updated_content = (
                prefix + 
                f"\n\\begin{{{after_type}}}{env_title}\n" + 
                streamed_content + 
                f"\n\\end{{{after_type}}}\n" + 
                suffix
            )
            
            # Write the updated content back to the file
            #with open(output_file, 'w', encoding='utf-8') as f:
            #    f.write(updated_content)

            self.write_with_lock(output_file, updated_content)
        
        # Final content with all streamed content
        elapsed_time = time.time() - start_time + self.recent_reasoning_time
        self.recent_reasoning_time = 0.0

        minutes = int(elapsed_time // 60)
        seconds = int(elapsed_time % 60)
        env_title = '['+f"{etitle} (generated in {minutes} minutes and {seconds} seconds.)"+']' if etitle else ''
        final_content = (
            prefix + 
            f"\n\\begin{{{after_type}}}{env_title}\n" + 
            streamed_content + 
            f"\n\\end{{{after_type}}}\n" + 
            suffix
        ) if streamed_content else prefix+suffix

        if not streamed_content and elapsed_time > 0:
            self.recent_reasoning_time = elapsed_time
        
        # Save the final content
        #with open(output_file, 'w', encoding='utf-8') as f:
        #    f.write(final_content)
        
        self.write_with_lock(output_file, final_content)
        
        # Update the internal state
        self.new_content = final_content
        self.new_envs = self._parse_environments(final_content)
        self.current_version_file = output_file
        self.current_content = final_content
        self.current_envs = self.new_envs
        self.new_version_file = None



# Example usage
if __name__ == "__main__":
    # Initialize with a current version
    tracker = LaTeXEnvTracker("old_version.tex")
    
    # Commit a new version
    tracker.commit("new_version.tex")
    
    # Get the differences
    differences = tracker.diff()
    print(f"Found {len(differences)} new environments:")
    print('\n'.join([f"{e.get('type', '')}: {e.get('text', '')}, {e.get('params', {})}" for e in differences]))
    
    # Get all environments from the current version
    current_envs = tracker.envs()
    
    env = differences[0]
    # Push new environments
    new_envs = [
        {
            "before":{env.get("type", ""): env.get("text", "")} ,
            "after": {"reasoning": "This is a new reasoning environment to add"}
        }
    ]
    tracker.push(new_envs)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
    env["params"]["status"] = f'completed_{timestamp}'
    updated_text = env.get("text", "") + "\n%parameters: " + \
        ','.join([f"{key}={value}" for key,value in env.get("params", {}).items()])
    tracker.update_env(env, updated_text)

    new_envs = [
        {
            "before":{"reasoning": "This is a new reasoning environment to add"},
            "after": {"output": "This is a new output environment to add"}
        }
    ]
    tracker.push(new_envs)


    
    # Save the updated version
    tracker.save("updated_version.tex")


    # Example of streaming content
    def character_generator():
        text = "This is being streamed character by character"
        for char in text:
            yield char
            time.sleep(1)  # Simulate slow generation
    
    # Stream content into a new environment
    tracker.commit("updated_version.tex")
    tracker.stream(
        new_env={
            "before":{env.get("type", ""): env.get("text", "")},
            "after": {"reasoning": character_generator()}
        },
        output_file="streamed_version.tex"
    )